<html>

<head>
  <script src="https://aframe.io/releases/1.0.2/aframe.min.js"></script>
  <script src="//cdn.rawgit.com/donmccurdy/aframe-physics-system/v4.0.1/dist/aframe-physics-system.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.0.1/dist/aframe-extras.min.js"></script>
  <script src="trigger-cylinder.js"></script>
  <script>
    $ = (sel) => document.querySelector(sel)
    $$ = (sel) => document.querySelectorAll(sel)
    on = (elem, type, hand) => elem.addEventListener(type, hand)

    const currentDisc = {
      speed: 9,// not in use
      glide: 4,
      turn: -1,
      fade: 2,
    };

    function forEach(arr, fn) {
      for (let index = 0; index < arr.length; index++) {
        fn(arr[index], index, arr);
      }
    }

    function map(arr, fn) {
      const res = [];
      for (let index = 0; index < arr.length; index++) {
        res.push(fn(arr[index], index, arr));
      }
      return res;
    }

    AFRAME.registerComponent('frisbee', {
      schema: {
        inBasket: { default: false }
      },

      init() {
        this.liftForce = new CANNON.Vec3();
        this.airFrictionForce = new CANNON.Vec3();
        this.discUpNormal = new CANNON.Vec3();
        this.center = new CANNON.Vec3();

        this.frisbeeTurn = new THREE.Quaternion();
        this.frisbeeTurn.z = 0.0;

        this.isDamped = false;
        this.discInBasketCheckScheduled = false;

        this.el.addEventListener('inside-trigger-zone', (e) => {
          this.isDamped = true;

          const shouldTestIfDiscIsInBasket = !this.data.inBasket && !this.discInBasketCheckScheduled;

          if (shouldTestIfDiscIsInBasket) {
            this.discInBasketCheckScheduled = true;

            setTimeout(() => {
              this.data.inBasket = this.isDamped;
              this.discInBasketCheckScheduled = false;
            }, 1000);
          }
        });
      },

      tick() {
        if (!this.el.body) return;

        this.discUpNormal.set(0, 1, 0);

        this.el.body.quaternion.vmult(this.discUpNormal, this.discUpNormal);

        const velocityMagnitude = this.el.body.velocity.length();
        const airFrictionMagnitude = -0.05 * velocityMagnitude ** 2;

        this.airFrictionForce.copy(this.el.body.velocity);
        this.airFrictionForce.normalize();
        this.airFrictionForce.scale(airFrictionMagnitude, this.airFrictionForce);

        const liftDot = this.discUpNormal.dot(this.el.body.velocity);
        const liftMagnitude = -5 * currentDisc.glide * liftDot;

        this.liftForce.copy(this.discUpNormal);
        this.liftForce.scale(liftMagnitude, this.liftForce);

        this.el.body.applyForce(this.liftForce, this.center);
        this.el.body.applyForce(this.airFrictionForce, this.center);

        if (velocityMagnitude > 2) {
          this.frisbeeTurn.z = ((currentDisc.fade / 2) + 0.09 * velocityMagnitude * (currentDisc.turn)) * 0.002;
        }

        if (this.isDamped) {
          this.el.body.velocity.x *= 0.3;
          this.el.body.velocity.z *= 0.3;
        }

        this.el.body.quaternion.mult(this.frisbeeTurn, this.el.body.quaternion);

        this.isDamped = false;
      }

    });

    AFRAME.registerComponent('frisbee-thrower', {
      init() {
        this.didThrow = false;
        this.shouldThrow = false;
        this.throwerPosition = new THREE.Vector3();
        this.frisbeeOrientation = new THREE.Quaternion();
        this.adjustingFrisbeeOrientation = false;

        window.addEventListener('mousemove', (e) => {
          if (this.adjustingFrisbeeOrientation) {
            this.frisbeeOrientation.x += e.movementY * 0.001;
            this.frisbeeOrientation.z -= e.movementX * 0.001;
          }
        });

        window.addEventListener('keydown', ({ key }) => {
          if (key === ' ') {
            $('[frisbee]').setAttribute('frisbee', 'inBasket', false);
            this.shouldThrow = true;
          }
          if (key === 'r') {
            this.shouldThrow = false;
            this.didThrow = false;

            this.frisbeeOrientation.z = 0;
            this.frisbeeOrientation.x = 0;
          }
          if (key === 'i') {
            this.frisbeeOrientation.x -= 0.1;
          }
          if (key === 'k') {
            this.frisbeeOrientation.x += 0.1;
          }
          if (key === 'j') {
            this.frisbeeOrientation.z += 0.1;
          }
          if (key === 'l') {
            this.frisbeeOrientation.z -= 0.1;
          }

          if (key === 'e') {
            const el = $('[look-controls]');

            if (el) {
              el.setAttribute('look-controls', 'enabled', false);
            }

            this.adjustingFrisbeeOrientation = true;
          }
        });

        window.addEventListener('keyup', ({ key }) => {
          if (key === 'e') {
            this.adjustingFrisbeeOrientation = false;
            const el = $('[look-controls]');
            if (el) {
              el.setAttribute('look-controls', 'enabled', true);
            }
          }
        });
      },

      tick() {
        if (this.didThrow) return;
        const { body } = $('#disc');
        if (!body) return;

        const pos = this.throwerPosition;

        const cam = this.el.object3D;
        cam.getWorldPosition(pos);

        const dist = 2;
        const x = -Math.sin(cam.rotation.y) * dist;
        const y = Math.sin(cam.rotation.x) * dist;
        const z = -Math.cos(cam.rotation.y) * dist;

        const toDisc = new CANNON.Vec3(x, y, z);
        const discPos = new CANNON.Vec3(pos.x, pos.y, pos.z);

        discPos.x += toDisc.x;
        discPos.y += toDisc.y - 0.3;
        discPos.z += toDisc.z;

        if (this.shouldThrow) {
          this.didThrow = true;
          const velocity = new CANNON.Vec3(x, y, z);
          velocity.normalize();
          velocity.scale(14, velocity);

          body.velocity.x = velocity.x;
          body.velocity.y = velocity.y;
          body.velocity.z = velocity.z;
        } else {
          body.position.set(discPos.x, discPos.y, discPos.z);
          body.velocity.setZero();
          body.quaternion.copy(cam.quaternion);
          body.quaternion.mult(this.frisbeeOrientation, body.quaternion);
          body.angularVelocity.setZero();
        }
      }

    });</script>
</head>

<body>
  <a-scene fog physics="debug:false;">
    <a-cylinder id="disc" radius="0.2" height="0.03" position="0.3 2 -4" material="color: #f80;" dynamic-body frisbee>
    </a-cylinder>

    <a-entity id="rig" movement-controls kinematic-body="radius: 0.7;" position="0 0.5 0">
      <a-entity id="camera" camera="fov:60;" frisbee-thrower look-controls="pointerLockEnabled: true"
        position="0 1.6 0">
      </a-entity>
    </a-entity>

    <a-cylinder radius="0.5" height="0.2" material="color: #777;" position="0 0.5 -5" static-body></a-cylinder>
    <a-cylinder radius="0.05" height="1.3" material="color: #777;" position="0 0.5 -5" static-body></a-cylinder>
    <a-cylinder radius="0.4" height="0.7" material="color: #888; opacity: 0.8; transparent: true;" position="0 0.9 -5"
      trigger-cylinder="selector: #disc">
    </a-cylinder>
    <a-cylinder radius="0.5" height="0.2" material="color: #DD3;" position="0 1.25 -5" static-body></a-cylinder>



    <a-box width="100" height="1" depth="100" position="0 -1 0" material="color: green" static-body></a-box>
    <a-box width="1" height="3" depth="1" position="5 0 3" material="color: #222" static-body></a-box>
    <a-box width="1" height="10" depth="1" position="5 0 3" material="color: #222" static-body></a-box>
    <a-box width="1" height="3" depth="1" position="-2 0 -1" material="color: #222" static-body></a-box>
  </a-scene>
</body>

</html>